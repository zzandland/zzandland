# Operating Systems Study Notes - Chapter 3
## Process
<hr>

#### Process Context
Process is a program in **execution**. 즉, 같은 프로그램이라도 개별적으로 실행된 프로세스는 다른 프로세스다. 시분할로 멀티태스킹을 하는 운영체제에서는 다른 프로세스를 CPU가 불러 올때마다 그 전에 있던 프로세스의 문맥을 저장한다. 문맥을 크게 3가지로 나눌수가 있다.

1. CPU 수행 상태를 나타내는 하드웨어 문맥: Program Counter (프로그램의 코드의 어느 위치까지 읽었는지) 등 각종 레지스터에 저장되 있는 상태들을 저장
2. 프로세스의 주소 공간: 프로세스에는 stack, data, code의 세 공간이 있고 각 함수 호출 상황, 자료구조 구현 상황, 그 프로그램의 코드등 여러가지를 저장
3. 프로세스 관련 커널 자료 구조: 새로운 프로세스가 만들어질때 마다 운영체제가 이 프로세스에 대해 가진 값이나 평가를 저장하는 PCB (Process Control Block)을 커널 주소공간의 data 부분에 저장. 또한, 프로세스들이 system call을 통해 커널코드를 호출할때 어떤 프로세스가 어떤 커널함수를 호출했는지 문맥을 커널 주소공간의 stack에 저장.

#### Process State

1. Running: 현재 CPU를 잡고 instruction을 수행중인 상태
2. Ready: 모든 준비를 마치고 CPU를 기다리는 상태.
3. Blocked: CPU를 잡을 준비가 안된 상태. Process address space에 다음 수행해야 되는 코드가 swap에 존재해 디스크를 불러와야 되는 경우, I/O device 호출이 완료 안된 경우. 요청한 event가 만족되면 Ready로 돌아감.
4. Suspended: 외부적인 이유 (User, Swapper)로 프로세스의 수행이 정지된 상태. 프로세스의 모든 메모리가 swap 디스크로 쫓겨남. 외부에서 resume을 해줘야만 Ready로 돌아감. Suspended Blocked에서 Suspended Ready로 복귀는 가능.
5. New: 프로세스가 생성중인 상태.
6. Terminated: 수행이 끝나고 프로세스를 종료중인 상태.

Ready 상태에 있는 프로세스들은 Ready 큐에서 대기를 하게 된다. Blocked 상태에 있는 프로세스들은 현재 기다리고 있는 I/O 장치 큐 혹은 공유 데이터 큐에서 대기를 하게 된다. 이 프로세스들은 원하는 데이터를 얻게 되었을때 Ready 상태로 돌아가고 Ready 큐에 진입한다. 이 큐들은 커널의 data영역에 저장.

#### PCB

1. OS가 관리상 사용하는 정보: pointer (큐에서 Linked List용), process state, process ID, scheduling information, priority
2. CPU 수행 관련 하드웨어 값 (이 부분들로부터 재시작): program counter, registers
3. 메모리 관련: code, data, stack의 정보가 메모리 어느부분에 있는지
4. 파일 관련: open file descriptors (어떤 파일들을 사용중인지, 열려있는 file stream 등)

#### Context Switch

1. CPU를 내어주는 프로세스의 상태를 그 프로세스의 PCB (커널의 data영역에 상주)에 저장.
2. CPU를 새롭게 얻는 프로세스의 상태를 PCB에서 불러옴.

Interrupt는 context switch가 아니다. Interrupt전후 프로세스가 다를때만 context switch. Context switch는 CPU cache flush를 하기에 부담이 훨씬 큼.

#### Scheduler

1. Short-term scheduler (CPU Scheduler): 어떤 프로레스를 다음번에 CPU에 줄지 결정 (ms 속도).
2. Long-term scheduler (job scheduler): 시작 프로세스중 어떤 것들을 ready 큐로 보내고 메모리 및 자원을 줄지 결정. Determines degree of multiprogramming (메모리에 있는 프로세스의 수를 결정). 시분할 시스템에선 없음 (모든 시작 프로그램을 ready 큐에 올림)
    a. 메모리에 프로세스 수가 너무 적을경우 ready 큐가 자주 비게됨 (CPU 놀게됨)
    b. 반대로 너무 많을 경우 각 프로세스가 대부분 swap에 저장을 해야되서 자주 disk IO를 해야함
3. Medium-term Scheduler (Swapper): 여유 공간 마련을 위해 프로세스를 통째로 메모리에서 디스크로 쫓아냄. Determines degree of multiprogramming.

#### Synchronous vs Asynchronous I/O

프로세스가 입출력이 진행되는 도중에 instruction을 수행할수 있는지 여부 (프로세스가 Running이든 Ready)이든 무관.

#### Thread

- A thread (lightweight process) is a basic unit of CPU utilization. Heavyweight process는 하나의 thread만 가지고 있는 process.
- 여러 쓰레드가 생성되면 프로세스의 주소공간의 stack 부분에 각 thread의 stack을 저장 및 보관하며, 커널의 data부분에 상주하는 PCB에서도 각자 thread의 program counter와 register 값들을 저장. 한 프로세스의 다른 코드 부분을 동시에 돌릴때 사용.
- 한 프로세스의 쓰레드들은 주소 공간과 자원을 공유. 별도로 가지고 있는 것은 CPU 수행 관련 정보. 공유하는 부분을 task라고 함. 자원 효율성 향상.
- 병렬성 향상 (동일한 일을 다중 쓰레드가 협력하여 높은 throughput과 성능 향상이 가능)
- 응답성 향상 (하나의 thread가 blocked 상태가 되도 다른 ready 상태의 thread가 처리 가능)
- 경제성 (creating & CPU switching thread가 context switch보다 훨씬 쌈)

#### Thread Implementation

커널이 제공하는 thread를 사용하는 경우 vs 라이브러리를 통해 구현하는 thread (user). User thread는 커널의 입장에선 존재 여부를 모름 (하나의 프로세스로만 보임)
